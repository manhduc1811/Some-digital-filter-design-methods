// -------------------------------------------------------------
//
// Module: filter
// Generated by MATLAB(R) 9.10 and Filter Design HDL Coder 3.1.9.
// Generated on: 2021-05-11 15:22:29
// -------------------------------------------------------------

// -------------------------------------------------------------
// HDL Code Generation Options:
//
// TargetDirectory: D:\0_G2touch_all\Script MATLAB\Script Active pen\Filter4FlyFish
// AddPipelineRegisters: on
// TargetLanguage: Verilog
// TestBenchStimulus: step ramp chirp 

// Filter Specifications:
//
// Sample Rate     : N/A (normalized frequency)
// Response        : Lowpass
// Specification   : Fp,Fst,Ap,Ast
// Stopband Atten. : 15 dB
// Passband Ripple : 1 dB
// Passband Edge   : 0.095362
// Stopband Edge   : 0.11443
// -------------------------------------------------------------

// -------------------------------------------------------------
// HDL Implementation    : Fully parallel
// Folding Factor        : 1
// -------------------------------------------------------------
// Filter Settings:
//
// Discrete-Time IIR Filter (real)
// -------------------------------
// Filter Structure    : Direct-Form II, Second-Order Sections
// Number of Sections  : 7
// Stable              : Yes
// Linear Phase        : No
// -------------------------------------------------------------




`timescale 1 ns / 1 ns

module filter
               (
                clk,
                clk_enable,
                reset,
                filter_in,
                filter_out
                );

  input   clk; 
  input   clk_enable; 
  input   reset; 
  input   [63:0] filter_in; //double
  output  [63:0] filter_out; //double

////////////////////////////////////////////////////////////////
//Module Architecture: filter
////////////////////////////////////////////////////////////////
  // Local Functions
  // Type Definitions
  // Constants
  parameter scaleconst1 = 2.3856741479405343E-02; //double
  parameter coeff_b1_section1 = 1.0000000000000000E+00; //double
  parameter coeff_b2_section1 = 2.0000000000000000E+00; //double
  parameter coeff_b3_section1 = 1.0000000000000000E+00; //double
  parameter coeff_a2_section1 = -1.8323695267376732E+00; //double
  parameter coeff_a3_section1 = 9.2779649265529440E-01; //double
  parameter scaleconst2 = 2.2293823931579637E-02; //double
  parameter coeff_b1_section2 = 1.0000000000000000E+00; //double
  parameter coeff_b2_section2 = 2.0000000000000000E+00; //double
  parameter coeff_b3_section2 = 1.0000000000000000E+00; //double
  parameter coeff_a2_section2 = -1.7123262052341206E+00; //double
  parameter coeff_a3_section2 = 8.0150150096043926E-01; //double
  parameter scaleconst3 = 2.1036977880866514E-02; //double
  parameter coeff_b1_section3 = 1.0000000000000000E+00; //double
  parameter coeff_b2_section3 = 2.0000000000000000E+00; //double
  parameter coeff_b3_section3 = 1.0000000000000000E+00; //double
  parameter coeff_a2_section3 = -1.6157913785849982E+00; //double
  parameter coeff_a3_section3 = 6.9993929010846434E-01; //double
  parameter scaleconst4 = 2.0080020254859093E-02; //double
  parameter coeff_b1_section4 = 1.0000000000000000E+00; //double
  parameter coeff_b2_section4 = 2.0000000000000000E+00; //double
  parameter coeff_b3_section4 = 1.0000000000000000E+00; //double
  parameter coeff_a2_section4 = -1.5422901423080762E+00; //double
  parameter coeff_a3_section4 = 6.2261022332751259E-01; //double
  parameter scaleconst5 = 1.9409930265488998E-02; //double
  parameter coeff_b1_section5 = 1.0000000000000000E+00; //double
  parameter coeff_b2_section5 = 2.0000000000000000E+00; //double
  parameter coeff_b3_section5 = 1.0000000000000000E+00; //double
  parameter coeff_a2_section5 = -1.4908224061231619E+00; //double
  parameter coeff_a3_section5 = 5.6846212718511779E-01; //double
  parameter scaleconst6 = 1.9013847569416271E-02; //double
  parameter coeff_b1_section6 = 1.0000000000000000E+00; //double
  parameter coeff_b2_section6 = 2.0000000000000000E+00; //double
  parameter coeff_b3_section6 = 1.0000000000000000E+00; //double
  parameter coeff_a2_section6 = -1.4604004030604931E+00; //double
  parameter coeff_a3_section6 = 5.3645579333815818E-01; //double
  parameter scaleconst7 = 1.3741494736572346E-01; //double
  parameter coeff_b1_section7 = 1.0000000000000000E+00; //double
  parameter coeff_b2_section7 = 1.0000000000000000E+00; //double
  parameter coeff_b3_section7 = 0.0000000000000000E+00; //double
  parameter coeff_a2_section7 = -7.2517010526855319E-01; //double
  parameter coeff_a3_section7 = 0.0000000000000000E+00; //double
  // Signals
  real input_register; // double
  real scale1; // double
  real scaletypeconvert1; // double
  // Section 1 Signals 
  real a1sum1; // double
  real a2sum1; // double
  real b1sum1; // double
  real b2sum1; // double
  real delay_section1 [0:1] ; // double
  real inputconv1; // double
  real a2mul1; // double
  real a3mul1; // double
  real b1mul1; // double
  real b2mul1; // double
  real b3mul1; // double
  real sos_pipeline1; // double
  real scale2; // double
  real scaletypeconvert2; // double
  // Section 2 Signals 
  real a1sum2; // double
  real a2sum2; // double
  real b1sum2; // double
  real b2sum2; // double
  real delay_section2 [0:1] ; // double
  real inputconv2; // double
  real a2mul2; // double
  real a3mul2; // double
  real b1mul2; // double
  real b2mul2; // double
  real b3mul2; // double
  real sos_pipeline2; // double
  real scale3; // double
  real scaletypeconvert3; // double
  // Section 3 Signals 
  real a1sum3; // double
  real a2sum3; // double
  real b1sum3; // double
  real b2sum3; // double
  real delay_section3 [0:1] ; // double
  real inputconv3; // double
  real a2mul3; // double
  real a3mul3; // double
  real b1mul3; // double
  real b2mul3; // double
  real b3mul3; // double
  real sos_pipeline3; // double
  real scale4; // double
  real scaletypeconvert4; // double
  // Section 4 Signals 
  real a1sum4; // double
  real a2sum4; // double
  real b1sum4; // double
  real b2sum4; // double
  real delay_section4 [0:1] ; // double
  real inputconv4; // double
  real a2mul4; // double
  real a3mul4; // double
  real b1mul4; // double
  real b2mul4; // double
  real b3mul4; // double
  real sos_pipeline4; // double
  real scale5; // double
  real scaletypeconvert5; // double
  // Section 5 Signals 
  real a1sum5; // double
  real a2sum5; // double
  real b1sum5; // double
  real b2sum5; // double
  real delay_section5 [0:1] ; // double
  real inputconv5; // double
  real a2mul5; // double
  real a3mul5; // double
  real b1mul5; // double
  real b2mul5; // double
  real b3mul5; // double
  real sos_pipeline5; // double
  real scale6; // double
  real scaletypeconvert6; // double
  // Section 6 Signals 
  real a1sum6; // double
  real a2sum6; // double
  real b1sum6; // double
  real b2sum6; // double
  real delay_section6 [0:1] ; // double
  real inputconv6; // double
  real a2mul6; // double
  real a3mul6; // double
  real b1mul6; // double
  real b2mul6; // double
  real b3mul6; // double
  real sos_pipeline6; // double
  real scale7; // double
  real scaletypeconvert7; // double
  //   -- Section 7 Signals 
  real a1sum7; // double
  real b1sum7; // double
  real delay_section7; // double
  real inputconv7; // double
  real a2mul7; // double
  real b1mul7; // double
  real b2mul7; // double
  real output_typeconvert; // double
  real output_register; // double

  // Block Statements
  always @ (posedge clk or posedge reset)
    begin: input_reg_process
      if (reset == 1'b1) begin
        input_register <= 0.0000000000000000E+00;
      end
      else begin
        if (clk_enable == 1'b1) begin
          input_register <= $bitstoreal(filter_in);
        end
      end
    end // input_reg_process

  always @* scale1 <= input_register * scaleconst1;

  always @* scaletypeconvert1 <= scale1;


  //   ------------------ Section 1 ------------------

  always @ (posedge clk or posedge reset)
    begin: delay_process_section1
      if (reset == 1'b1) begin
        delay_section1[0] <= 0.0000000000000000E+00;
        delay_section1[1] <= 0.0000000000000000E+00;
      end
      else begin
        if (clk_enable == 1'b1) begin
          delay_section1[1] <= delay_section1[0];
          delay_section1[0] <= a1sum1;
        end
      end
    end // delay_process_section1

  always @* inputconv1 <= scaletypeconvert1;


  always @* a2mul1 <= delay_section1[0] * coeff_a2_section1;

  always @* a3mul1 <= delay_section1[1] * coeff_a3_section1;

  always @* b1mul1 <= a1sum1;


  always @* b2mul1 <= delay_section1[0] * coeff_b2_section1;

  always @* b3mul1 <= delay_section1[1];


  always @* a2sum1 <= inputconv1 - a2mul1;

  always @* a1sum1 <= a2sum1 - a3mul1;

  always @* b2sum1 <= b1mul1 + b2mul1;

  always @* b1sum1 <= b2sum1 + b3mul1;

  always @ (posedge clk or posedge reset)
    begin: sos_pipeline_process_section1
      if (reset == 1'b1) begin
        sos_pipeline1 <= 0.0000000000000000E+00;
      end
      else begin
        if (clk_enable == 1'b1) begin
          sos_pipeline1 <= b1sum1;
        end
      end
    end // sos_pipeline_process_section1

  always @* scale2 <= sos_pipeline1 * scaleconst2;

  always @* scaletypeconvert2 <= scale2;


  //   ------------------ Section 2 ------------------

  always @ (posedge clk or posedge reset)
    begin: delay_process_section2
      if (reset == 1'b1) begin
        delay_section2[0] <= 0.0000000000000000E+00;
        delay_section2[1] <= 0.0000000000000000E+00;
      end
      else begin
        if (clk_enable == 1'b1) begin
          delay_section2[1] <= delay_section2[0];
          delay_section2[0] <= a1sum2;
        end
      end
    end // delay_process_section2

  always @* inputconv2 <= scaletypeconvert2;


  always @* a2mul2 <= delay_section2[0] * coeff_a2_section2;

  always @* a3mul2 <= delay_section2[1] * coeff_a3_section2;

  always @* b1mul2 <= a1sum2;


  always @* b2mul2 <= delay_section2[0] * coeff_b2_section2;

  always @* b3mul2 <= delay_section2[1];


  always @* a2sum2 <= inputconv2 - a2mul2;

  always @* a1sum2 <= a2sum2 - a3mul2;

  always @* b2sum2 <= b1mul2 + b2mul2;

  always @* b1sum2 <= b2sum2 + b3mul2;

  always @ (posedge clk or posedge reset)
    begin: sos_pipeline_process_section2
      if (reset == 1'b1) begin
        sos_pipeline2 <= 0.0000000000000000E+00;
      end
      else begin
        if (clk_enable == 1'b1) begin
          sos_pipeline2 <= b1sum2;
        end
      end
    end // sos_pipeline_process_section2

  always @* scale3 <= sos_pipeline2 * scaleconst3;

  always @* scaletypeconvert3 <= scale3;


  //   ------------------ Section 3 ------------------

  always @ (posedge clk or posedge reset)
    begin: delay_process_section3
      if (reset == 1'b1) begin
        delay_section3[0] <= 0.0000000000000000E+00;
        delay_section3[1] <= 0.0000000000000000E+00;
      end
      else begin
        if (clk_enable == 1'b1) begin
          delay_section3[1] <= delay_section3[0];
          delay_section3[0] <= a1sum3;
        end
      end
    end // delay_process_section3

  always @* inputconv3 <= scaletypeconvert3;


  always @* a2mul3 <= delay_section3[0] * coeff_a2_section3;

  always @* a3mul3 <= delay_section3[1] * coeff_a3_section3;

  always @* b1mul3 <= a1sum3;


  always @* b2mul3 <= delay_section3[0] * coeff_b2_section3;

  always @* b3mul3 <= delay_section3[1];


  always @* a2sum3 <= inputconv3 - a2mul3;

  always @* a1sum3 <= a2sum3 - a3mul3;

  always @* b2sum3 <= b1mul3 + b2mul3;

  always @* b1sum3 <= b2sum3 + b3mul3;

  always @ (posedge clk or posedge reset)
    begin: sos_pipeline_process_section3
      if (reset == 1'b1) begin
        sos_pipeline3 <= 0.0000000000000000E+00;
      end
      else begin
        if (clk_enable == 1'b1) begin
          sos_pipeline3 <= b1sum3;
        end
      end
    end // sos_pipeline_process_section3

  always @* scale4 <= sos_pipeline3 * scaleconst4;

  always @* scaletypeconvert4 <= scale4;


  //   ------------------ Section 4 ------------------

  always @ (posedge clk or posedge reset)
    begin: delay_process_section4
      if (reset == 1'b1) begin
        delay_section4[0] <= 0.0000000000000000E+00;
        delay_section4[1] <= 0.0000000000000000E+00;
      end
      else begin
        if (clk_enable == 1'b1) begin
          delay_section4[1] <= delay_section4[0];
          delay_section4[0] <= a1sum4;
        end
      end
    end // delay_process_section4

  always @* inputconv4 <= scaletypeconvert4;


  always @* a2mul4 <= delay_section4[0] * coeff_a2_section4;

  always @* a3mul4 <= delay_section4[1] * coeff_a3_section4;

  always @* b1mul4 <= a1sum4;


  always @* b2mul4 <= delay_section4[0] * coeff_b2_section4;

  always @* b3mul4 <= delay_section4[1];


  always @* a2sum4 <= inputconv4 - a2mul4;

  always @* a1sum4 <= a2sum4 - a3mul4;

  always @* b2sum4 <= b1mul4 + b2mul4;

  always @* b1sum4 <= b2sum4 + b3mul4;

  always @ (posedge clk or posedge reset)
    begin: sos_pipeline_process_section4
      if (reset == 1'b1) begin
        sos_pipeline4 <= 0.0000000000000000E+00;
      end
      else begin
        if (clk_enable == 1'b1) begin
          sos_pipeline4 <= b1sum4;
        end
      end
    end // sos_pipeline_process_section4

  always @* scale5 <= sos_pipeline4 * scaleconst5;

  always @* scaletypeconvert5 <= scale5;


  //   ------------------ Section 5 ------------------

  always @ (posedge clk or posedge reset)
    begin: delay_process_section5
      if (reset == 1'b1) begin
        delay_section5[0] <= 0.0000000000000000E+00;
        delay_section5[1] <= 0.0000000000000000E+00;
      end
      else begin
        if (clk_enable == 1'b1) begin
          delay_section5[1] <= delay_section5[0];
          delay_section5[0] <= a1sum5;
        end
      end
    end // delay_process_section5

  always @* inputconv5 <= scaletypeconvert5;


  always @* a2mul5 <= delay_section5[0] * coeff_a2_section5;

  always @* a3mul5 <= delay_section5[1] * coeff_a3_section5;

  always @* b1mul5 <= a1sum5;


  always @* b2mul5 <= delay_section5[0] * coeff_b2_section5;

  always @* b3mul5 <= delay_section5[1];


  always @* a2sum5 <= inputconv5 - a2mul5;

  always @* a1sum5 <= a2sum5 - a3mul5;

  always @* b2sum5 <= b1mul5 + b2mul5;

  always @* b1sum5 <= b2sum5 + b3mul5;

  always @ (posedge clk or posedge reset)
    begin: sos_pipeline_process_section5
      if (reset == 1'b1) begin
        sos_pipeline5 <= 0.0000000000000000E+00;
      end
      else begin
        if (clk_enable == 1'b1) begin
          sos_pipeline5 <= b1sum5;
        end
      end
    end // sos_pipeline_process_section5

  always @* scale6 <= sos_pipeline5 * scaleconst6;

  always @* scaletypeconvert6 <= scale6;


  //   ------------------ Section 6 ------------------

  always @ (posedge clk or posedge reset)
    begin: delay_process_section6
      if (reset == 1'b1) begin
        delay_section6[0] <= 0.0000000000000000E+00;
        delay_section6[1] <= 0.0000000000000000E+00;
      end
      else begin
        if (clk_enable == 1'b1) begin
          delay_section6[1] <= delay_section6[0];
          delay_section6[0] <= a1sum6;
        end
      end
    end // delay_process_section6

  always @* inputconv6 <= scaletypeconvert6;


  always @* a2mul6 <= delay_section6[0] * coeff_a2_section6;

  always @* a3mul6 <= delay_section6[1] * coeff_a3_section6;

  always @* b1mul6 <= a1sum6;


  always @* b2mul6 <= delay_section6[0] * coeff_b2_section6;

  always @* b3mul6 <= delay_section6[1];


  always @* a2sum6 <= inputconv6 - a2mul6;

  always @* a1sum6 <= a2sum6 - a3mul6;

  always @* b2sum6 <= b1mul6 + b2mul6;

  always @* b1sum6 <= b2sum6 + b3mul6;

  always @ (posedge clk or posedge reset)
    begin: sos_pipeline_process_section6
      if (reset == 1'b1) begin
        sos_pipeline6 <= 0.0000000000000000E+00;
      end
      else begin
        if (clk_enable == 1'b1) begin
          sos_pipeline6 <= b1sum6;
        end
      end
    end // sos_pipeline_process_section6

  always @* scale7 <= sos_pipeline6 * scaleconst7;

  always @* scaletypeconvert7 <= scale7;


  //   ------------------ Section 7 (First Order) ------------------

  always @ (posedge clk or posedge reset)
    begin: delay_process_section7
      if (reset == 1'b1) begin
        delay_section7 <= 0.0000000000000000E+00;
      end
      else begin
        if (clk_enable == 1'b1) begin
          delay_section7 <= a1sum7;
        end
      end
    end // delay_process_section7

  always @* inputconv7 <= scaletypeconvert7;


  always @* a2mul7 <= delay_section7 * coeff_a2_section7;

  always @* b1mul7 <= a1sum7;


  always @* b2mul7 <= delay_section7;


  always @* a1sum7 <= inputconv7 - a2mul7;

  always @* b1sum7 <= b1mul7 + b2mul7;

  always @* output_typeconvert <= b1sum7;


  always @ (posedge clk or posedge reset)
    begin: Output_Register_process
      if (reset == 1'b1) begin
        output_register <= 0.0000000000000000E+00;
      end
      else begin
        if (clk_enable == 1'b1) begin
          output_register <= output_typeconvert;
        end
      end
    end // Output_Register_process

  // Assignment Statements
  assign filter_out = $realtobits(output_register);
endmodule  // filter
